
# 带有 Postgres、Redis、前端和源码挂载，用来做本地开发；本地启动请用


services:
  db:
    image: postgres:16-alpine
    container_name: yarra-postgres
    restart: unless-stopped
    env_file: [ ./.env ]
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-yarra_dev}
      POSTGRES_USER: ${POSTGRES_USER:-ys_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-ys_pass}
      TZ: ${TZ:-Australia/Melbourne}   
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-ys_user} -d ${POSTGRES_DB:-yarra_dev}"]
      interval: 5s
      timeout: 3s
      retries: 10


  redis:
    image: redis:7-alpine
    container_name: yarra-redis
    restart: unless-stopped
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redisdata:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 6


  backend:
    container_name: yarra-backend
    build:
      context: ../backend  # dev container运行
      #context: ./backend   # 本地运行
      dockerfile: Dockerfile           # ✅ Dockerfile 就在 backend 目录下
    env_file: [ ./.env ]
    restart: unless-stopped
    environment:
      PYTHONPATH: /yarra-workdir/backend
      ALEMBIC_CONFIG: /yarra-workdir/backend/alembic.ini    # 环境变量，告诉 alembic 配置文件在哪里，是容器内的绝对路径
      # alembic.ini 实际就在容器的 /yarra-workdir/backend/alembic.ini
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
    ports:
      - "8000:8000"
      - "5678:5678"   # Python 远程调试端口
    volumes:
      # - ..:/yarra-workdir          # dev container使用
      - ../backend:/yarra-workdir/backend              # ✅ 仅挂载 backend 目录，减少歧义和性能风险
    command: >
      bash -lc "uvicorn app.main:app --host 0.0.0.0 --port 8000"
      
    # 如果使用本地证书 + 跨站 + HTTPS
    # --ssl-keyfile /certs/api.local.test-key.pem
      # --ssl-certfile /certs/api.local.test.pem"


  # Celery（worker/beat）也挂相同源码目录 → 改任务代码无需重建镜像，开发效率高。
  worker:
    container_name: yarra-celery-worker
    build: { context: ../backend }
    env_file: [ ./.env ]
    environment:
      PYTHONPATH: /yarra-workdir/backend
    depends_on:
      db: { condition: service_healthy }
      redis: { condition: service_started }
    volumes:
      - ../backend:/yarra-workdir/backend
    command: >
      bash -lc "celery -A app.core.celery_app worker -l info"  
      # 指向 Celery 应用实例，不是包目录，导入celery_app.py, 拿里面名为 celery_app 的实例, 使用实例配置的broker_url
    restart: unless-stopped


  beat:
    container_name: yarra-celery-beat
    build: { context: ../backend }
    env_file: [ ./.env ]
    environment:
      PYTHONPATH: /yarra-workdir/backend
    depends_on:
      db: { condition: service_healthy }
      redis: { condition: service_started }
    volumes:
      - ../backend:/yarra-workdir/backend
    command: >
      bash -lc "celery -A app.core.celery_app beat -l info"
    restart: unless-stopped


  frontend:
    build:
      context: ../frontend
    env_file: [ ./.env ]      # 注入 VITE_* 变量
    # ports/command 依你的项目打开：
    # ports: [ "5173:5173" ]
    # volumes: [ "../frontend:/yarra-workdir" ]
    # command: [ "npm", "run", "dev" ]

volumes:
  pgdata:
  redisdata:
